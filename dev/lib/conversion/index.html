<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions between set representations · LazySets.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../binary_functions/">Concrete Operations</a></li><li class="is-active"><a class="tocitem" href>Conversions between set representations</a></li><li><a class="tocitem" href="../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../approximations/">Approximations</a></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Conversions between set representations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversions between set representations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/conversion.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversion-between-set-representations"><a class="docs-heading-anchor" href="#Conversion-between-set-representations">Conversion between set representations</a><a id="Conversion-between-set-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-set-representations" title="Permalink"></a></h1><p>This section of the manual lists the conversion functions between set representations.</p><ul><li><a href="#Conversion-between-set-representations">Conversion between set representations</a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, VPolygon}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, VPolygon}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(T::Type{HPOLYGON}, P::VPolygon) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code> – type used for dispatch</li><li><code>P</code>        – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle}, AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Hyperrectangle}, AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, H::AbstractHyperrectangle)</code></pre><p>Convert a hyperrectangular set to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – hyperrectangle type, used for dispatch</li><li><code>H</code>              – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; convert(Hyperrectangle, Interval(0.0, 1.0))
Hyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([0.5], [0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L587-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval}, AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Interval}, AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>H</code>        – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; convert(Interval, Hyperrectangle([0.5], [0.5]))
Interval{Float64, IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L612-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Interval}, LazySet{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Interval}, LazySet{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Converts a convex set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>S</code>        – convex set</li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L638-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, HN}}} where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, HN}}} where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, HN}) where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L657-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, Interval{N}}) where {N&lt;:Real}</code></pre><p>Converts the cartesian product of a finite number of intervals to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of intervals</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>min</code> and <code>max</code> methods of <code>Interval</code> to reduce the allocatons and improve performance (see LazySets#1143).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L722-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPOLYGON}, H::AbstractHyperrectangle) where
    {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a hyperrectangular set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>  – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L854-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON}, HPolytope{N, VN}}} where {N&lt;:Real, VN&lt;:AbstractVector{N}, HPOLYGON&lt;:AbstractHPolygon}" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON}, HPolytope{N, VN}}} where {N&lt;:Real, VN&lt;:AbstractVector{N}, HPOLYGON&lt;:AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPOLYGON}, P::HPolytope{N, VN};
        prune::Bool=true) where {N&lt;:Real, VN&lt;:AbstractVector{N}, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from 2D polytope in H-representation to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>P</code>     – source polytope (must be 2D)</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L285-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON}, AbstractSingleton{N}}} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON}, AbstractSingleton{N}}} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPOLYGON}, S::AbstractSingleton{N}
       ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from singleton to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>S</code>    – singleton</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation with the minimal number of constraints (three).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L529-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPOLYGON}, L::LineSegment{N}
      ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from line segment to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L557-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, LazySet}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON}, LazySet}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPOLYGON}, X::LazySet; [check_boundedness]::Bool=true) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a polyhedral set to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>PT</code> – type used for dispatch</li><li><code>X</code>  – set</li><li><code>check_boundedness</code> – (optional, default <code>true</code>) if <code>true</code> check whether the                        set <code>X</code> is bounded before creating the polygon</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We compute the list of constraints of <code>X</code>, then instantiate the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L30-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolyhedron}, AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolyhedron}, AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolyhedron}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polyhedron in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L180-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope}, AbstractHPolygon}" href="#Base.convert-Tuple{Type{HPolytope}, AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolytope}, P::AbstractHPolygon)</code></pre><p>Convert from polygon in H-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as 2D polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope}, AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{HPolytope}, AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolytope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolytope</code> – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polytope in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L835-L848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope}, AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolytope}, AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolytope}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polytope in constraint representation.</p><p><strong>Algorithm</strong></p><p>First the list of constraints of <code>P</code> is computed, then the corresponding <code>HPolytope</code> is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L157-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope}, VPolytope}" href="#Base.convert-Tuple{Type{HPolytope}, VPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolytope}, P::VPolytope)</code></pre><p>Convert from polytope in V-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tohrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L212-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon}, AbstractHPolygon}" href="#Base.convert-Tuple{Type{VPolygon}, AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolygon}, P::AbstractHPolygon)</code></pre><p>Converts a polygon in constraint representation to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code> – type used for dispatch</li><li><code>P</code>        – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L59-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon}, AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolygon}, AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolygon}, P::AbstractPolytope)</code></pre><p>Convert polytopic set to polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as a polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L113-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope}, LazySet}" href="#Base.convert-Tuple{Type{VPolytope}, LazySet}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolytope}, X::LazySet; [prune]::Bool=true)</code></pre><p>Generic conversion to polytope in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>X</code>     – set</li><li><code>prune</code> – (optional, default: <code>true</code>) option to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>The given set represented as a polytope in vertex representation.</p><p><strong>Algorithm</strong></p><p>We compute the list of vertices of <code>X</code> and wrap the result in a polytope in vertex representation, <code>VPolytope</code>. Use the option <code>prune</code> to select whether or not to remove redundant vertices before constructing the polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L238-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope}, AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolytope}, AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolytope}, P::AbstractPolytope)</code></pre><p>Convert polytopic type to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The set <code>P</code> represented as a <code>VPolytope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope}, HPolytope}" href="#Base.convert-Tuple{Type{VPolytope}, HPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolytope}, P::HPolytope)</code></pre><p>Convert from polytope in H-representation to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tovrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L263-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Zonotope}, AbstractZonotope}" href="#Base.convert-Tuple{Type{Zonotope}, AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, Z::AbstractZonotope)</code></pre><p>Converts a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>H</code>        – zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L372-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox}, AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox}, AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{IntervalArithmetic.IntervalBox}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an <code>IntervalBox</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>IntervalBox</code> – type used for dispatch</li><li><code>H</code>           – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An <code>IntervalBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L912-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle}, IntervalArithmetic.IntervalBox}" href="#Base.convert-Tuple{Type{Hyperrectangle}, IntervalArithmetic.IntervalBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, IB::IntervalArithmetic.IntervalBox)</code></pre><p>Converts an <code>IntervalBox</code> from <code>IntervalArithmetic</code> to a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>IB</code>             – interval box</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p><p><strong>Notes</strong></p><p><code>IntervalArithmetic.IntervalBox</code> uses <em>static</em> vectors to store each component interval, hence the resulting <code>Hyperrectangle</code> has its center and radius represented as a static vector (<code>SArray</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L930-L949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, ZN1, ZN2}}} where {N&lt;:Real, ZN1&lt;:AbstractZonotope{N}, ZN2&lt;:AbstractZonotope{N}}" href="#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, ZN1, ZN2}}} where {N&lt;:Real, ZN1&lt;:AbstractZonotope{N}, ZN2&lt;:AbstractZonotope{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}
       ) where {N&lt;:Real, ZN1&lt;:AbstractZonotope{N}, ZN2&lt;:AbstractZonotope{N}}</code></pre><p>Converts the cartesian product of two zonotopes to a new zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>S</code>        – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>The cartesian product is obtained by:</p><ul><li>Concatenating the centers of each input zonotope.</li><li>Arranging the generators in block-diagional fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L803-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProduct{N, HN1, HN2}}} where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProduct{N, HN1, HN2}}} where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle},
        cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L693-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, HN1, HN2}}} where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, HN1, HN2}}} where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real,
        HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cp</code>       – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L402-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, HN}}} where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, HN}}} where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})
    where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product array of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cpa</code>      – cartesian product array of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L424-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, ZN, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, ZN&lt;:AbstractZonotope{N}}" href="#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, ZN, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, ZN&lt;:AbstractZonotope{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, S::LinearMap{N, ZN}
       ) where {N, ZN&lt;:AbstractZonotope{N}}</code></pre><p>Converts the lazy linear map of a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first applies the (concrete) linear map to the zonotopic set and then converts the result to a <code>Zonotope</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L449-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProduct{N, HN1, HN2}, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProduct{N, HN1, HN2}, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}
       ) where {N, HN1&lt;:AbstractHyperrectangle{N},
                HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of the cartesian product of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L474-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProductArray{N, HN}, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, HN&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProductArray{N, HN}, NM, MAT} where {NM, MAT&lt;:AbstractMatrix{NM}}}} where {N, HN&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}}
       ) where {N, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of a finite number of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a <code>CartesianProductArray</code> of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L503-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}, AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}, AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a two-dimensional hyperrectangle to the cartesian product of two intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProduct</code> – type used for dispatch</li><li><code>H</code>                – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of two intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L756-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}, AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N, Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}, AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{CartesianProductArray{N, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a hyperrectangle to the cartesian product array of intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProductArray</code> – type used for dispatch</li><li><code>H</code>                     – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of a finite number of intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L782-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle}, Rectification{N, AH}}} where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}" href="#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle}, Rectification{N, AH}}} where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, r::Rectification{N, AH})
    where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts a rectification of a hyperrectangle to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>r</code>              – rectification of a hyperrectangle</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L956-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval}, Rectification{N, IN}}} where {N&lt;:Real, IN&lt;:(Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N})}" href="#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval}, Rectification{N, IN}}} where {N&lt;:Real, IN&lt;:(Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N})}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval},
        r::Rectification{N, IN}) where {N&lt;:Real, IN&lt;:Interval{N}}</code></pre><p>Converts a rectification of an interval to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>r</code>        – rectification of an interval</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L977-L991">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.Interval}, Interval}" href="#Base.convert-Tuple{Type{IntervalArithmetic.Interval}, Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{IntervalArithmetic.Interval}, x::Interval)</code></pre><p>Converts a <code>LazySets</code> interval to an <code>Interval</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch, from <code>IntervalArithmetic</code></li><li><code>x</code>        – interval (<code>LazySets.Interval</code>)</li></ul><p><strong>Output</strong></p><p>An <code>IntervalArithmetic.Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L876-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval}, IntervalArithmetic.Interval}" href="#Base.convert-Tuple{Type{Interval}, IntervalArithmetic.Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, x::IntervalArithmetic.Interval)</code></pre><p>Converts an <code>Interval</code> from <code>IntervalArithmetic</code> to an interval in <code>LazySets</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – interval (<code>IntervalArithmetic.Interval</code>)</li></ul><p><strong>Output</strong></p><p>A <code>LazySets.Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L894-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope}, ConvexHullArray{N, Singleton{N, VT}}}} where {N, VT}" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope}, ConvexHullArray{N, Singleton{N, VT}}}} where {N, VT}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolytope},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolytope</code> – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polytope in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L997-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon}, ConvexHullArray{N, Singleton{N, VT}}}} where {N, VT}" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon}, ConvexHullArray{N, Singleton{N, VT}}}} where {N, VT}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolygon},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code>  – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1017-L1031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon}, LazySet}" href="#Base.convert-Tuple{Type{VPolygon}, LazySet}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolygon}, X::LazySet)</code></pre><p>Generic conversion to polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>X</code>    – set</li></ul><p><strong>Output</strong></p><p>The 2D set represented as a polygon.</p><p><strong>Algorithm</strong></p><p>We compute the list of vertices of <code>X</code> and wrap the result in a polygon in vertex representation, which guarantees that the vertices are sorted in counter-clockwise fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L132-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray}, MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}}} where {N, ST}" href="#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray}, MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}}} where {N, ST}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{MinkowskiSumArray},
        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}</code></pre><p>Converts the Minkowski sum of a Minkowski sum array to a Minkowski sum array.</p><p><strong>Input</strong></p><ul><li><code>MinkowskiSumArray</code>  – type used for dispatch</li><li><code>X</code>                  – Minkowski sum of a Minkowski sum array</li></ul><p><strong>Output</strong></p><p>A Minkowski sum array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1038-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval}, MinkowskiSum{N, IT, IT}}} where {N, IT&lt;:(Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N})}" href="#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval}, MinkowskiSum{N, IT, IT}}} where {N, IT&lt;:(Interval{N, IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N})}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, x::MinkowskiSum{N, IT, IT}) where {N, IT&lt;:Interval{N}}</code></pre><p>Converts the Minkowski sum of two intervals into an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – Minkowski sum of a pair of intervals</li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1058-L1071">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{HParallelotope}, AbstractZonotope{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{HParallelotope}, AbstractZonotope{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HParallelotope}, Z::AbstractZonotope{N}) where {N}</code></pre><p>Converts a zonotopic set of order one into a parallelotope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HParallelotope</code> – type used for dispatch</li><li><code>Z</code>              – zonotopic set</li></ul><p><strong>Output</strong></p><p>A parallelotope in constraint representation.</p><p><strong>Notes</strong></p><p>This function requires that the list of constraints of <code>Z</code> are obtained in the particular order returned from the constraints list function of a <code>Zonotope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1087-L1106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AZ2}, Tuple{AZ1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, AZ1, AZ2}}} where {N, AZ1&lt;:AbstractZonotope{N}, AZ2&lt;:AbstractZonotope{N}}" href="#Base.convert-Union{Tuple{AZ2}, Tuple{AZ1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, AZ1, AZ2}}} where {N, AZ1&lt;:AbstractZonotope{N}, AZ2&lt;:AbstractZonotope{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cp::CartesianProduct{N, AZ1, AZ2}) where
     {N, AZ1&lt;:AbstractZonotope{N}, AZ2&lt;:AbstractZonotope{N}}</code></pre><p>Converts a cartesian product of two zonotopes into a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>cp</code>       – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Notes</strong></p><p>This implementation creates a <code>Zonotope</code> with sparse vector and matrix representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1127-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, AZ}}} where {N, AZ&lt;:AbstractZonotope{N}}" href="#Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, AZ}}} where {N, AZ&lt;:AbstractZonotope{N}}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, AZ})
    where {N, AZ&lt;:AbstractZonotope{N}}</code></pre><p>Converts a cartesian product array of zonotopes into a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>cpa</code>       – cartesian product array of zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Notes</strong></p><p>This function requires the use of <code>SparseArrays</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1154-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, AbstractPolyhedron{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, AbstractPolyhedron{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{STAR}, P::AbstractPolyhedron{N}) where {N}</code></pre><p>Converts a polyhedral set into a star set represented as a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>STAR</code> – type used for dispatch</li><li><code>P</code>    – polyhedral set</li></ul><p><strong>Output</strong></p><p>A star set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1198-L1211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, Star}" href="#Base.convert-Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, Star}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{STAR}, X::Star)</code></pre><p>Converts a star set into its equivalent representation as a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>STAR</code> – type used for dispatch</li><li><code>X</code>    – star set</li></ul><p><strong>Output</strong></p><p>A star set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1219-L1232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Star}, AbstractPolyhedron{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Star}, AbstractPolyhedron{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Star}, P::AbstractPolyhedron{N}) where {N}</code></pre><p>Converts a polyhedral set into a star set.</p><p><strong>Input</strong></p><ul><li><code>Star</code> – type used for dispatch</li><li><code>P</code>    – polyhedral set</li></ul><p><strong>Output</strong></p><p>A star set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e6c68b262354dc82f663535d1ccd6de7ffb1c554/src/convert.jl#L1237-L1250">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../binary_functions/">« Concrete Operations</a><a class="docs-footer-nextpage" href="../comparisons/">Comparisons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Wednesday 15 September 2021 03:47">Wednesday 15 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
